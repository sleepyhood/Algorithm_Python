n = int(input())
lst = list(map(int, input().split()))

# cnt[x] = 현재 윈도우(구간 [l, r)) 안에서 값 x가 몇 번 등장했는지
cnt = [0] * 100001

l, r = 0, 0             # 투 포인터: 윈도우는 [l, r) (r은 포함 X)
ans = 0
tmp = 1                 # "현재 r을 1 증가시킨 직후" 새로 생기는 부분수열 개수 (= 윈도우 길이 r-l)

while l < n and r < n:
    # case 1) lst[r]이 윈도우 안에 아직 없다면 -> 중복 없이 확장 가능
    if cnt[lst[r]] == 0:
        cnt[lst[r]] += 1
        r += 1

        # r-1을 끝으로 하는 "중복 없는 연속 부분수열" 개수는
        # 윈도우 길이 (r - l)개.
        # 이 코드는 그 값을 tmp로 관리하면서 누적한다.
        ans += tmp
        tmp += 1        # 방금 r이 1 늘었으니, 윈도우 길이도 1 늘어났다고 반영

    # case 2) lst[r]이 이미 윈도우에 있다면 -> 중복 제거 필요
    else:
        # 왼쪽을 한 칸씩 줄이면서 중복이 사라지도록 만든다.
        # (중복이 없어질 때까지 반복하는 방식도 가능하지만,
        #  여기서는 while 바깥 루프가 다시 검사하므로 한 칸씩만 줄여도 된다.)
        cnt[lst[l]] -= 1
        l += 1

        # l이 1 증가하면 윈도우 길이(r-l)는 1 감소하므로 tmp도 1 감소시켜 동기화
        # (tmp는 최소 1로 유지: 원소 1개 부분수열은 항상 가능)
        tmp = tmp - 1 if tmp > 1 else 1

print(ans)
